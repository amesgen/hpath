<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>HPath.IO</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">hpath-0.9.2: Support for well-typed paths</span><ul class="links" id="page-menu"><li><a href="src/HPath.IO.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>&#169; 2016 Julian Ospald</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>Julian Ospald &lt;hasufell@posteo.de&gt;</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">HPath.IO</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Types</a></li><li><a href="#g:2">File copying</a></li><li><a href="#g:3">File deletion</a></li><li><a href="#g:4">File opening</a></li><li><a href="#g:5">File creation</a></li><li><a href="#g:6">File renaming/moving</a></li><li><a href="#g:7">File reading</a></li><li><a href="#g:8">File writing</a></li><li><a href="#g:9">File permissions</a></li><li><a href="#g:10">Directory reading</a></li><li><a href="#g:11">Filetype operations</a></li><li><a href="#g:12">Others</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides high-level IO related file operations like
 copy, delete, move and so on. It only operates on <em>Path x</em> which
 guarantees us well-typed paths. Passing in <em>Path Abs</em> to any
 of these functions generally increases safety. Passing <em>Path Rel</em>
 may trigger looking up the current directory via <code>getcwd</code> in some
 cases where it cannot be avoided.</p><p>Some functions are just path-safe wrappers around
 unix functions, others have stricter exception handling
 and some implement functionality that doesn't have a unix
 counterpart (like <code><a href="HPath-IO.html#v:copyDirRecursive" title="HPath.IO">copyDirRecursive</a></code>).</p><p>Some of these operations are due to their nature <strong>not atomic</strong>, which
 means they may do multiple syscalls which form one context. Some
 of them also have to examine the filetypes explicitly before the
 syscalls, so a reasonable decision can be made. That means
 the result is undefined if another process changes that context
 while the non-atomic operation is still happening. However, where
 possible, as few syscalls as possible are used and the underlying
 exception handling is kept.</p><p>Note: <code><a href="HPath-IO.html#v:BlockDevice" title="HPath.IO">BlockDevice</a></code>, <code><a href="HPath-IO.html#v:CharacterDevice" title="HPath.IO">CharacterDevice</a></code>, <code><a href="HPath-IO.html#v:NamedPipe" title="HPath.IO">NamedPipe</a></code> and <code><a href="HPath-IO.html#v:Socket" title="HPath.IO">Socket</a></code>
 are ignored by some of the more high-level functions (like <code><a href="HPath-IO.html#v:easyCopy" title="HPath.IO">easyCopy</a></code>).
 For other functions (like <code><a href="HPath-IO.html#v:copyFile" title="HPath.IO">copyFile</a></code>), the behavior on these file types is
 unreliable/unsafe. Check the documentation of those functions for details.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:FileType">FileType</a><ul class="subs"><li>= <a href="#v:Directory">Directory</a></li><li>| <a href="#v:RegularFile">RegularFile</a></li><li>| <a href="#v:SymbolicLink">SymbolicLink</a></li><li>| <a href="#v:BlockDevice">BlockDevice</a></li><li>| <a href="#v:CharacterDevice">CharacterDevice</a></li><li>| <a href="#v:NamedPipe">NamedPipe</a></li><li>| <a href="#v:Socket">Socket</a></li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:RecursiveErrorMode">RecursiveErrorMode</a><ul class="subs"><li>= <a href="#v:FailEarly">FailEarly</a></li><li>| <a href="#v:CollectFailures">CollectFailures</a></li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:CopyMode">CopyMode</a><ul class="subs"><li>= <a href="#v:Strict">Strict</a></li><li>| <a href="#v:Overwrite">Overwrite</a></li></ul></li><li class="src short"><a href="#v:copyDirRecursive">copyDirRecursive</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b1 -&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b2 -&gt; <a href="HPath-IO.html#t:CopyMode" title="HPath.IO">CopyMode</a> -&gt; <a href="HPath-IO.html#t:RecursiveErrorMode" title="HPath.IO">RecursiveErrorMode</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:recreateSymlink">recreateSymlink</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b1 -&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b2 -&gt; <a href="HPath-IO.html#t:CopyMode" title="HPath.IO">CopyMode</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:copyFile">copyFile</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b1 -&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b2 -&gt; <a href="HPath-IO.html#t:CopyMode" title="HPath.IO">CopyMode</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:easyCopy">easyCopy</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b1 -&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b2 -&gt; <a href="HPath-IO.html#t:CopyMode" title="HPath.IO">CopyMode</a> -&gt; <a href="HPath-IO.html#t:RecursiveErrorMode" title="HPath.IO">RecursiveErrorMode</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:deleteFile">deleteFile</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:deleteDir">deleteDir</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:deleteDirRecursive">deleteDirRecursive</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:easyDelete">easyDelete</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:openFile">openFile</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-Posix-Types.html#t:ProcessID" title="System.Posix.Types">ProcessID</a></li><li class="src short"><a href="#v:executeFile">executeFile</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; [<a href="https://hackage.haskell.org/package/bytestring-0.10.9.0/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>] -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-Posix-Types.html#t:ProcessID" title="System.Posix.Types">ProcessID</a></li><li class="src short"><a href="#v:createRegularFile">createRegularFile</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-Posix-Types.html#t:FileMode" title="System.Posix.Types">FileMode</a> -&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:createDir">createDir</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-Posix-Types.html#t:FileMode" title="System.Posix.Types">FileMode</a> -&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:createDirRecursive">createDirRecursive</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-Posix-Types.html#t:FileMode" title="System.Posix.Types">FileMode</a> -&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:createSymlink">createSymlink</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/bytestring-0.10.9.0/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:renameFile">renameFile</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b1 -&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b2 -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:moveFile">moveFile</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b1 -&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b2 -&gt; <a href="HPath-IO.html#t:CopyMode" title="HPath.IO">CopyMode</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:readFile">readFile</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.9.0/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></li><li class="src short"><a href="#v:readFileEOF">readFileEOF</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.9.0/docs/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></li><li class="src short"><a href="#v:writeFile">writeFile</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/bytestring-0.10.9.0/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:appendFile">appendFile</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/bytestring-0.10.9.0/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:newFilePerms">newFilePerms</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-Posix-Types.html#t:FileMode" title="System.Posix.Types">FileMode</a></li><li class="src short"><a href="#v:newDirPerms">newDirPerms</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-Posix-Types.html#t:FileMode" title="System.Posix.Types">FileMode</a></li><li class="src short"><a href="#v:getDirsFiles">getDirsFiles</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> [<a href="HPath.html#t:Path" title="HPath">Path</a> b]</li><li class="src short"><a href="#v:getFileType">getFileType</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="HPath-IO.html#t:FileType" title="HPath.IO">FileType</a></li><li class="src short"><a href="#v:canonicalizePath">canonicalizePath</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="HPath.html#t:Path" title="HPath">Path</a> <a href="HPath.html#t:Abs" title="HPath">Abs</a>)</li><li class="src short"><a href="#v:toAbs">toAbs</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="HPath.html#t:Path" title="HPath">Path</a> <a href="HPath.html#t:Abs" title="HPath">Abs</a>)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Types</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:FileType" class="def">FileType</a> <a href="src/HPath.IO.html#FileType" class="link">Source</a> <a href="#t:FileType" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Directory" class="def">Directory</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:RegularFile" class="def">RegularFile</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:SymbolicLink" class="def">SymbolicLink</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:BlockDevice" class="def">BlockDevice</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:CharacterDevice" class="def">CharacterDevice</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:NamedPipe" class="def">NamedPipe</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Socket" class="def">Socket</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:FileType">Instances</h4><details id="i:FileType" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:FileType:Eq:1"></span> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> <a href="HPath-IO.html#t:FileType" title="HPath.IO">FileType</a></span> <a href="src/HPath.IO.html#line-254" class="link">Source</a> <a href="#t:FileType" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:FileType:Eq:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="HPath-IO.html">HPath.IO</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="HPath-IO.html#t:FileType" title="HPath.IO">FileType</a> -&gt; <a href="HPath-IO.html#t:FileType" title="HPath.IO">FileType</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="HPath-IO.html#t:FileType" title="HPath.IO">FileType</a> -&gt; <a href="HPath-IO.html#t:FileType" title="HPath.IO">FileType</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:FileType:Show:2"></span> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> <a href="HPath-IO.html#t:FileType" title="HPath.IO">FileType</a></span> <a href="src/HPath.IO.html#line-254" class="link">Source</a> <a href="#t:FileType" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:FileType:Show:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="HPath-IO.html">HPath.IO</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="HPath-IO.html#t:FileType" title="HPath.IO">FileType</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="HPath-IO.html#t:FileType" title="HPath.IO">FileType</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="HPath-IO.html#t:FileType" title="HPath.IO">FileType</a>] -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:RecursiveErrorMode" class="def">RecursiveErrorMode</a> <a href="src/HPath.IO.html#RecursiveErrorMode" class="link">Source</a> <a href="#t:RecursiveErrorMode" class="selflink">#</a></p><div class="doc"><p>The error mode for recursive operations.</p><p>On <code><a href="HPath-IO.html#v:FailEarly" title="HPath.IO">FailEarly</a></code> the whole operation fails immediately if any of the
 recursive sub-operations fail, which is sort of the default
 for IO operations.</p><p>On <code><a href="HPath-IO.html#v:CollectFailures" title="HPath.IO">CollectFailures</a></code> skips errors in the recursion and keeps on recursing.
 However all errors are collected in the <code><a href="HPath-IO-Errors.html#v:RecursiveFailure" title="HPath.IO.Errors">RecursiveFailure</a></code> error type,
 which is raised finally if there was any error. Also note that
 <code><a href="HPath-IO-Errors.html#v:RecursiveFailure" title="HPath.IO.Errors">RecursiveFailure</a></code> does not give any guarantees on the ordering
 of the collected exceptions.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:FailEarly" class="def">FailEarly</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:CollectFailures" class="def">CollectFailures</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:CopyMode" class="def">CopyMode</a> <a href="src/HPath.IO.html#CopyMode" class="link">Source</a> <a href="#t:CopyMode" class="selflink">#</a></p><div class="doc"><p>The mode for copy and file moves.
 Overwrite mode is usually not very well defined, but is a convenience
 shortcut.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Strict" class="def">Strict</a></td><td class="doc"><p>fail if any target exists</p></td></tr><tr><td class="src"><a id="v:Overwrite" class="def">Overwrite</a></td><td class="doc"><p>overwrite targets</p></td></tr></table></div></div><a href="#g:2" id="g:2"><h1>File copying</h1></a><div class="top"><p class="src"><a id="v:copyDirRecursive" class="def">copyDirRecursive</a> <a href="src/HPath.IO.html#copyDirRecursive" class="link">Source</a> <a href="#v:copyDirRecursive" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="HPath.html#t:Path" title="HPath">Path</a> b1</td><td class="doc"><p>source dir</p></td></tr><tr><td class="src">-&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b2</td><td class="doc"><p>destination (parent dirs
   are not automatically created)</p></td></tr><tr><td class="src">-&gt; <a href="HPath-IO.html#t:CopyMode" title="HPath.IO">CopyMode</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="HPath-IO.html#t:RecursiveErrorMode" title="HPath.IO">RecursiveErrorMode</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Copies the contents of a directory recursively to the given destination, while preserving permissions.
 Does not follow symbolic links. This behaves more or less like
 the following, without descending into the destination if it
 already exists:</p><pre>  cp -a /source/dir /destination/somedir
</pre><p>For directory contents, this will ignore any file type that is not
 <code><a href="HPath-IO.html#v:RegularFile" title="HPath.IO">RegularFile</a></code>, <code><a href="HPath-IO.html#v:SymbolicLink" title="HPath.IO">SymbolicLink</a></code> or <code><a href="HPath-IO.html#v:Directory" title="HPath.IO">Directory</a></code>.</p><p>For <code><a href="HPath-IO.html#v:Overwrite" title="HPath.IO">Overwrite</a></code> copy mode this does not prune destination directory
 contents, so the destination might contain more files than the source after
 the operation has completed. Permissions of existing directories are
 fixed.</p><p>Safety/reliability concerns:</p><ul><li>not atomic</li><li>examines filetypes explicitly</li><li>an explicit check <code><a href="HPath-IO-Errors.html#v:throwDestinationInSource" title="HPath.IO.Errors">throwDestinationInSource</a></code> is carried out for the
      top directory for basic sanity, because otherwise we might end up
      with an infinite copy loop... however, this operation is not
      carried out recursively (because it's slow)</li></ul><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if source directory does not exist</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if source directory can't be opened</li><li><code><a href="HPath-IO-Errors.html#v:SameFile" title="HPath.IO.Errors">SameFile</a></code> if source and destination are the same file
      (<code><a href="HPath-IO-Errors.html#t:HPathIOException" title="HPath.IO.Errors">HPathIOException</a></code>)</li><li><code><a href="HPath-IO-Errors.html#v:DestinationInSource" title="HPath.IO.Errors">DestinationInSource</a></code> if destination is contained in source
      (<code><a href="HPath-IO-Errors.html#t:HPathIOException" title="HPath.IO.Errors">HPathIOException</a></code>)</li></ul><p>Throws in <code><a href="HPath-IO.html#v:FailEarly" title="HPath.IO">FailEarly</a></code> RecursiveErrorMode only:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if output directory is not writable</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:InvalidArgument" title="GHC.IO.Exception">InvalidArgument</a></code> if source directory is wrong type (symlink)</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:InappropriateType" title="GHC.IO.Exception">InappropriateType</a></code> if source directory is wrong type (regular file)</li></ul><p>Throws in <code><a href="HPath-IO.html#v:CollectFailures" title="HPath.IO">CollectFailures</a></code> RecursiveErrorMode only:</p><ul><li><code><a href="HPath-IO-Errors.html#v:RecursiveFailure" title="HPath.IO.Errors">RecursiveFailure</a></code> if any of the recursive operations that are not
      part of the top-directory sanity-checks fail (<code><a href="HPath-IO-Errors.html#t:HPathIOException" title="HPath.IO.Errors">HPathIOException</a></code>)</li></ul><p>Throws in <code><a href="HPath-IO.html#v:Strict" title="HPath.IO">Strict</a></code> CopyMode only:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:AlreadyExists" title="GHC.IO.Exception">AlreadyExists</a></code> if destination already exists</li></ul><p>Note: may call <code>getcwd</code> (only if destination is a relative path)</p></div></div><div class="top"><p class="src"><a id="v:recreateSymlink" class="def">recreateSymlink</a> <a href="src/HPath.IO.html#recreateSymlink" class="link">Source</a> <a href="#v:recreateSymlink" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="HPath.html#t:Path" title="HPath">Path</a> b1</td><td class="doc"><p>the old symlink file</p></td></tr><tr><td class="src">-&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b2</td><td class="doc"><p>destination file</p></td></tr><tr><td class="src">-&gt; <a href="HPath-IO.html#t:CopyMode" title="HPath.IO">CopyMode</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Recreate a symlink.</p><p>In <code><a href="HPath-IO.html#v:Overwrite" title="HPath.IO">Overwrite</a></code> copy mode only files and empty directories are deleted.</p><p>Safety/reliability concerns:</p><ul><li><code><a href="HPath-IO.html#v:Overwrite" title="HPath.IO">Overwrite</a></code> mode is inherently non-atomic</li></ul><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:InvalidArgument" title="GHC.IO.Exception">InvalidArgument</a></code> if source file is wrong type (not a symlink)</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if output directory cannot be written to</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if source directory cannot be opened</li><li><code><a href="HPath-IO-Errors.html#v:SameFile" title="HPath.IO.Errors">SameFile</a></code> if source and destination are the same file
      (<code><a href="HPath-IO-Errors.html#t:HPathIOException" title="HPath.IO.Errors">HPathIOException</a></code>)</li></ul><p>Throws in <code><a href="HPath-IO.html#v:Strict" title="HPath.IO">Strict</a></code> mode only:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:AlreadyExists" title="GHC.IO.Exception">AlreadyExists</a></code> if destination already exists</li></ul><p>Throws in <code><a href="HPath-IO.html#v:Overwrite" title="HPath.IO">Overwrite</a></code> mode only:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:UnsatisfiedConstraints" title="GHC.IO.Exception">UnsatisfiedConstraints</a></code> if destination file is non-empty directory</li></ul><p>Notes:</p><ul><li>calls <code>symlink</code></li><li>calls <code>getcwd</code> in Overwrite mode (if destination is a relative path)</li></ul></div></div><div class="top"><p class="src"><a id="v:copyFile" class="def">copyFile</a> <a href="src/HPath.IO.html#copyFile" class="link">Source</a> <a href="#v:copyFile" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="HPath.html#t:Path" title="HPath">Path</a> b1</td><td class="doc"><p>source file</p></td></tr><tr><td class="src">-&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b2</td><td class="doc"><p>destination file</p></td></tr><tr><td class="src">-&gt; <a href="HPath-IO.html#t:CopyMode" title="HPath.IO">CopyMode</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Copies the given regular file to the given destination.
 Neither follows symbolic links, nor accepts them.
 For &quot;copying&quot; symbolic links, use <code><a href="HPath-IO.html#v:recreateSymlink" title="HPath.IO">recreateSymlink</a></code> instead.</p><p>Note that this is still sort of a low-level function and doesn't
 examine file types. For a more high-level version, use <code><a href="HPath-IO.html#v:easyCopy" title="HPath.IO">easyCopy</a></code>
 instead.</p><p>In <code><a href="HPath-IO.html#v:Overwrite" title="HPath.IO">Overwrite</a></code> copy mode only overwrites actual files, not directories.
 In <code><a href="HPath-IO.html#v:Strict" title="HPath.IO">Strict</a></code> mode the destination file must not exist.</p><p>Safety/reliability concerns:</p><ul><li><code><a href="HPath-IO.html#v:Overwrite" title="HPath.IO">Overwrite</a></code> mode is not atomic</li><li>when used on <code><a href="HPath-IO.html#v:CharacterDevice" title="HPath.IO">CharacterDevice</a></code>, reads the &quot;contents&quot; and copies
      them to a regular file, which might take indefinitely</li><li>when used on <code><a href="HPath-IO.html#v:BlockDevice" title="HPath.IO">BlockDevice</a></code>, may either read the &quot;contents&quot;
      and copy them to a regular file (potentially hanging indefinitely)
      or may create a regular empty destination file</li><li>when used on <code><a href="HPath-IO.html#v:NamedPipe" title="HPath.IO">NamedPipe</a></code>, will hang indefinitely</li></ul><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if source file does not exist</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if source file is a a <code><a href="HPath-IO.html#v:Socket" title="HPath.IO">Socket</a></code></li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if output directory is not writable</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if source directory can't be opened</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:InvalidArgument" title="GHC.IO.Exception">InvalidArgument</a></code> if source file is wrong type (symlink or directory)</li><li><code><a href="HPath-IO-Errors.html#v:SameFile" title="HPath.IO.Errors">SameFile</a></code> if source and destination are the same file
      (<code><a href="HPath-IO-Errors.html#t:HPathIOException" title="HPath.IO.Errors">HPathIOException</a></code>)</li></ul><p>Throws in <code><a href="HPath-IO.html#v:Strict" title="HPath.IO">Strict</a></code> mode only:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:AlreadyExists" title="GHC.IO.Exception">AlreadyExists</a></code> if destination already exists</li></ul><p>Notes:</p><ul><li>may call <code>getcwd</code> in Overwrite mode (if destination is a relative path)</li></ul></div></div><div class="top"><p class="src"><a id="v:easyCopy" class="def">easyCopy</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b1 -&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b2 -&gt; <a href="HPath-IO.html#t:CopyMode" title="HPath.IO">CopyMode</a> -&gt; <a href="HPath-IO.html#t:RecursiveErrorMode" title="HPath.IO">RecursiveErrorMode</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/HPath.IO.html#easyCopy" class="link">Source</a> <a href="#v:easyCopy" class="selflink">#</a></p><div class="doc"><p>Copies a regular file, directory or symbolic link. In case of a
 symbolic link it is just recreated, even if it points to a directory.
 Any other file type is ignored.</p><p>Safety/reliability concerns:</p><ul><li>examines filetypes explicitly</li><li>calls <code><a href="HPath-IO.html#v:copyDirRecursive" title="HPath.IO">copyDirRecursive</a></code> for directories</li></ul><p>Note: may call <code>getcwd</code> in Overwrite mode (if destination is a relative path)</p></div></div><a href="#g:3" id="g:3"><h1>File deletion</h1></a><div class="top"><p class="src"><a id="v:deleteFile" class="def">deleteFile</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/HPath.IO.html#deleteFile" class="link">Source</a> <a href="#v:deleteFile" class="selflink">#</a></p><div class="doc"><p>Deletes the given file. Raises <code>eISDIR</code>
 if run on a directory. Does not follow symbolic links.</p><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:InappropriateType" title="GHC.IO.Exception">InappropriateType</a></code> for wrong file type (directory)</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if the file does not exist</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if the directory cannot be read</li></ul></div></div><div class="top"><p class="src"><a id="v:deleteDir" class="def">deleteDir</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/HPath.IO.html#deleteDir" class="link">Source</a> <a href="#v:deleteDir" class="selflink">#</a></p><div class="doc"><p>Deletes the given directory, which must be empty, never symlinks.</p><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:InappropriateType" title="GHC.IO.Exception">InappropriateType</a></code> for wrong file type (symlink to directory)</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:InappropriateType" title="GHC.IO.Exception">InappropriateType</a></code> for wrong file type (regular file)</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if directory does not exist</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:UnsatisfiedConstraints" title="GHC.IO.Exception">UnsatisfiedConstraints</a></code> if directory is not empty</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if we can't open or write to parent directory</li></ul><p>Notes: calls <code>rmdir</code></p></div></div><div class="top"><p class="src"><a id="v:deleteDirRecursive" class="def">deleteDirRecursive</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/HPath.IO.html#deleteDirRecursive" class="link">Source</a> <a href="#v:deleteDirRecursive" class="selflink">#</a></p><div class="doc"><p>Deletes the given directory recursively. Does not follow symbolic
 links. Tries <code><a href="HPath-IO.html#v:deleteDir" title="HPath.IO">deleteDir</a></code> first before attemtping a recursive
 deletion.</p><p>On directory contents this behaves like <code><a href="HPath-IO.html#v:easyDelete" title="HPath.IO">easyDelete</a></code>
 and thus will ignore any file type that is not <code><a href="HPath-IO.html#v:RegularFile" title="HPath.IO">RegularFile</a></code>,
 <code><a href="HPath-IO.html#v:SymbolicLink" title="HPath.IO">SymbolicLink</a></code> or <code><a href="HPath-IO.html#v:Directory" title="HPath.IO">Directory</a></code>.</p><p>Safety/reliability concerns:</p><ul><li>not atomic</li><li>examines filetypes explicitly</li></ul><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:InappropriateType" title="GHC.IO.Exception">InappropriateType</a></code> for wrong file type (symlink to directory)</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:InappropriateType" title="GHC.IO.Exception">InappropriateType</a></code> for wrong file type (regular file)</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if directory does not exist</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if we can't open or write to parent directory</li></ul></div></div><div class="top"><p class="src"><a id="v:easyDelete" class="def">easyDelete</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/HPath.IO.html#easyDelete" class="link">Source</a> <a href="#v:easyDelete" class="selflink">#</a></p><div class="doc"><p>Deletes a file, directory or symlink.
 In case of directory, performs recursive deletion. In case of
 a symlink, the symlink file is deleted.
 Any other file type is ignored.</p><p>Safety/reliability concerns:</p><ul><li>examines filetypes explicitly</li><li>calls <code><a href="HPath-IO.html#v:deleteDirRecursive" title="HPath.IO">deleteDirRecursive</a></code> for directories</li></ul></div></div><a href="#g:4" id="g:4"><h1>File opening</h1></a><div class="top"><p class="src"><a id="v:openFile" class="def">openFile</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-Posix-Types.html#t:ProcessID" title="System.Posix.Types">ProcessID</a> <a href="src/HPath.IO.html#openFile" class="link">Source</a> <a href="#v:openFile" class="selflink">#</a></p><div class="doc"><p>Opens a file appropriately by invoking xdg-open. The file type
 is not checked. This forks a process.</p></div></div><div class="top"><p class="src"><a id="v:executeFile" class="def">executeFile</a> <a href="src/HPath.IO.html#executeFile" class="link">Source</a> <a href="#v:executeFile" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="HPath.html#t:Path" title="HPath">Path</a> b</td><td class="doc"><p>program</p></td></tr><tr><td class="src">-&gt; [<a href="https://hackage.haskell.org/package/bytestring-0.10.9.0/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>]</td><td class="doc"><p>arguments</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-Posix-Types.html#t:ProcessID" title="System.Posix.Types">ProcessID</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Executes a program with the given arguments. This forks a process.</p></div></div><a href="#g:5" id="g:5"><h1>File creation</h1></a><div class="top"><p class="src"><a id="v:createRegularFile" class="def">createRegularFile</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-Posix-Types.html#t:FileMode" title="System.Posix.Types">FileMode</a> -&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/HPath.IO.html#createRegularFile" class="link">Source</a> <a href="#v:createRegularFile" class="selflink">#</a></p><div class="doc"><p>Create an empty regular file at the given directory with the given
 filename.</p><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if output directory cannot be written to</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:AlreadyExists" title="GHC.IO.Exception">AlreadyExists</a></code> if destination already exists</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if any of the parent components of the path
      do not exist</li></ul></div></div><div class="top"><p class="src"><a id="v:createDir" class="def">createDir</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-Posix-Types.html#t:FileMode" title="System.Posix.Types">FileMode</a> -&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/HPath.IO.html#createDir" class="link">Source</a> <a href="#v:createDir" class="selflink">#</a></p><div class="doc"><p>Create an empty directory at the given directory with the given filename.</p><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if output directory cannot be written to</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:AlreadyExists" title="GHC.IO.Exception">AlreadyExists</a></code> if destination already exists</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if any of the parent components of the path
      do not exist</li></ul></div></div><div class="top"><p class="src"><a id="v:createDirRecursive" class="def">createDirRecursive</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-Posix-Types.html#t:FileMode" title="System.Posix.Types">FileMode</a> -&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/HPath.IO.html#createDirRecursive" class="link">Source</a> <a href="#v:createDirRecursive" class="selflink">#</a></p><div class="doc"><p>Create an empty directory at the given directory with the given filename.
 All parent directories are created with the same filemode. This
 basically behaves like:</p><pre>  mkdir -p /some/dir
</pre><p>Safety/reliability concerns:</p><ul><li>not atomic</li></ul><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if any part of the path components do not
      exist and cannot be written to</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:AlreadyExists" title="GHC.IO.Exception">AlreadyExists</a></code> if destination already exists and
      is not a directory</li></ul><p>Note: calls <code>getcwd</code> if the input path is a relative path</p></div></div><div class="top"><p class="src"><a id="v:createSymlink" class="def">createSymlink</a> <a href="src/HPath.IO.html#createSymlink" class="link">Source</a> <a href="#v:createSymlink" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="HPath.html#t:Path" title="HPath">Path</a> b</td><td class="doc"><p>destination file</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/bytestring-0.10.9.0/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>path the symlink points to</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Create a symlink.</p><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if output directory cannot be written to</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:AlreadyExists" title="GHC.IO.Exception">AlreadyExists</a></code> if destination file already exists</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if any of the parent components of the path
      do not exist</li></ul><p>Note: calls <code>symlink</code></p></div></div><a href="#g:6" id="g:6"><h1>File renaming/moving</h1></a><div class="top"><p class="src"><a id="v:renameFile" class="def">renameFile</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b1 -&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b2 -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/HPath.IO.html#renameFile" class="link">Source</a> <a href="#v:renameFile" class="selflink">#</a></p><div class="doc"><p>Rename a given file with the provided filename. Destination and source
 must be on the same device, otherwise <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Foreign-C-Error.html#v:eXDEV" title="Foreign.C.Error">eXDEV</a></code> will be raised.</p><p>Does not follow symbolic links, but renames the symbolic link file.</p><p>Safety/reliability concerns:</p><ul><li>has a separate set of exception handling, apart from the syscall</li></ul><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if source file does not exist</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if output directory cannot be written to</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if source directory cannot be opened</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:UnsupportedOperation" title="GHC.IO.Exception">UnsupportedOperation</a></code> if source and destination are on different
       devices</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:AlreadyExists" title="GHC.IO.Exception">AlreadyExists</a></code> if destination already exists</li><li><code><a href="HPath-IO-Errors.html#v:SameFile" title="HPath.IO.Errors">SameFile</a></code> if destination and source are the same file
       (<code><a href="HPath-IO-Errors.html#t:HPathIOException" title="HPath.IO.Errors">HPathIOException</a></code>)</li></ul><p>Note: calls <code><a href="https://hackage.haskell.org/package/unix-2.7.2.2/docs/System-Posix-Files-ByteString.html#v:rename" title="System.Posix.Files.ByteString">rename</a></code> (but does not allow to rename over existing files)</p></div></div><div class="top"><p class="src"><a id="v:moveFile" class="def">moveFile</a> <a href="src/HPath.IO.html#moveFile" class="link">Source</a> <a href="#v:moveFile" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="HPath.html#t:Path" title="HPath">Path</a> b1</td><td class="doc"><p>file to move</p></td></tr><tr><td class="src">-&gt; <a href="HPath.html#t:Path" title="HPath">Path</a> b2</td><td class="doc"><p>destination</p></td></tr><tr><td class="src">-&gt; <a href="HPath-IO.html#t:CopyMode" title="HPath.IO">CopyMode</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Move a file. This also works across devices by copy-delete fallback.
 And also works on directories.</p><p>Does not follow symbolic links, but renames the symbolic link file.</p><p>Safety/reliability concerns:</p><ul><li><code><a href="HPath-IO.html#v:Overwrite" title="HPath.IO">Overwrite</a></code> mode is not atomic</li><li>copy-delete fallback is inherently non-atomic</li><li>since this function calls <code><a href="HPath-IO.html#v:easyCopy" title="HPath.IO">easyCopy</a></code> and <code><a href="HPath-IO.html#v:easyDelete" title="HPath.IO">easyDelete</a></code> as a fallback
      to <code><a href="HPath-IO.html#v:renameFile" title="HPath.IO">renameFile</a></code>, file types that are not <code><a href="HPath-IO.html#v:RegularFile" title="HPath.IO">RegularFile</a></code>, <code><a href="HPath-IO.html#v:SymbolicLink" title="HPath.IO">SymbolicLink</a></code>
      or <code><a href="HPath-IO.html#v:Directory" title="HPath.IO">Directory</a></code> may be ignored</li><li>for <code><a href="HPath-IO.html#v:Overwrite" title="HPath.IO">Overwrite</a></code> mode, the destination will be deleted (not recursively)
      before moving</li></ul><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if source file does not exist</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if output directory cannot be written to</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if source directory cannot be opened</li><li><code><a href="HPath-IO-Errors.html#v:SameFile" title="HPath.IO.Errors">SameFile</a></code> if destination and source are the same file
       (<code><a href="HPath-IO-Errors.html#t:HPathIOException" title="HPath.IO.Errors">HPathIOException</a></code>)</li></ul><p>Throws in <code><a href="HPath-IO.html#v:Strict" title="HPath.IO">Strict</a></code> mode only:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:AlreadyExists" title="GHC.IO.Exception">AlreadyExists</a></code> if destination already exists</li></ul><p>Notes:</p><ul><li>calls <code><a href="https://hackage.haskell.org/package/unix-2.7.2.2/docs/System-Posix-Files-ByteString.html#v:rename" title="System.Posix.Files.ByteString">rename</a></code> (but does not allow to rename over existing files)</li><li>calls <code>getcwd</code> in Overwrite mode if destination is a relative path</li></ul></div></div><a href="#g:7" id="g:7"><h1>File reading</h1></a><div class="top"><p class="src"><a id="v:readFile" class="def">readFile</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.9.0/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="src/HPath.IO.html#readFile" class="link">Source</a> <a href="#v:readFile" class="selflink">#</a></p><div class="doc"><p>Read the given file at once into memory as a strict ByteString.
 Symbolic links are followed, no sanity checks on file size
 or file type. File must exist.</p><p>Note: the size of the file is determined in advance, as to only
 have one allocation.</p><p>Safety/reliability concerns:</p><ul><li>since amount of bytes to read is determined in advance,
      the file might be read partially only if something else is
      appending to it while reading</li><li>the whole file is read into memory!</li></ul><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:InappropriateType" title="GHC.IO.Exception">InappropriateType</a></code> if file is not a regular file or a symlink</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if we cannot read the file or the directory
        containting it</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if the file does not exist</li></ul></div></div><div class="top"><p class="src"><a id="v:readFileEOF" class="def">readFileEOF</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.9.0/docs/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> <a href="src/HPath.IO.html#readFileEOF" class="link">Source</a> <a href="#v:readFileEOF" class="selflink">#</a></p><div class="doc"><p>Read the given file in chunks of size `8192` into memory until
 <code>fread</code> returns 0. Returns a lazy ByteString, because it uses
 Builders under the hood.</p><p>Safety/reliability concerns:</p><ul><li>the whole file is read into memory!</li></ul><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:InappropriateType" title="GHC.IO.Exception">InappropriateType</a></code> if file is not a regular file or a symlink</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if we cannot read the file or the directory
        containting it</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if the file does not exist</li></ul></div></div><a href="#g:8" id="g:8"><h1>File writing</h1></a><div class="top"><p class="src"><a id="v:writeFile" class="def">writeFile</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/bytestring-0.10.9.0/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/HPath.IO.html#writeFile" class="link">Source</a> <a href="#v:writeFile" class="selflink">#</a></p><div class="doc"><p>Write a given ByteString to a file, truncating the file beforehand.
 The file must exist. Follows symlinks.</p><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:InappropriateType" title="GHC.IO.Exception">InappropriateType</a></code> if file is not a regular file or a symlink</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if we cannot read the file or the directory
        containting it</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if the file does not exist</li></ul></div></div><div class="top"><p class="src"><a id="v:appendFile" class="def">appendFile</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/bytestring-0.10.9.0/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/HPath.IO.html#appendFile" class="link">Source</a> <a href="#v:appendFile" class="selflink">#</a></p><div class="doc"><p>Append a given ByteString to a file.
 The file must exist. Follows symlinks.</p><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:InappropriateType" title="GHC.IO.Exception">InappropriateType</a></code> if file is not a regular file or a symlink</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if we cannot read the file or the directory
        containting it</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if the file does not exist</li></ul></div></div><a href="#g:9" id="g:9"><h1>File permissions</h1></a><div class="top"><p class="src"><a id="v:newFilePerms" class="def">newFilePerms</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-Posix-Types.html#t:FileMode" title="System.Posix.Types">FileMode</a> <a href="src/HPath.IO.html#newFilePerms" class="link">Source</a> <a href="#v:newFilePerms" class="selflink">#</a></p><div class="doc"><p>Default permissions for a new file.</p></div></div><div class="top"><p class="src"><a id="v:newDirPerms" class="def">newDirPerms</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-Posix-Types.html#t:FileMode" title="System.Posix.Types">FileMode</a> <a href="src/HPath.IO.html#newDirPerms" class="link">Source</a> <a href="#v:newDirPerms" class="selflink">#</a></p><div class="doc"><p>Default permissions for a new directory.</p></div></div><a href="#g:10" id="g:10"><h1>Directory reading</h1></a><div class="top"><p class="src"><a id="v:getDirsFiles" class="def">getDirsFiles</a> <a href="src/HPath.IO.html#getDirsFiles" class="link">Source</a> <a href="#v:getDirsFiles" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="HPath.html#t:Path" title="HPath">Path</a> b</td><td class="doc"><p>dir to read</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> [<a href="HPath.html#t:Path" title="HPath">Path</a> b]</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Gets all filenames of the given directory. This excludes &quot;.&quot; and &quot;..&quot;.
 This version does not follow symbolic links.</p><p>The contents are not sorted and there is no guarantee on the ordering.</p><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if directory does not exist</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:InappropriateType" title="GHC.IO.Exception">InappropriateType</a></code> if file type is wrong (file)</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:InappropriateType" title="GHC.IO.Exception">InappropriateType</a></code> if file type is wrong (symlink to file)</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:InappropriateType" title="GHC.IO.Exception">InappropriateType</a></code> if file type is wrong (symlink to dir)</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if directory cannot be opened</li></ul></div></div><a href="#g:11" id="g:11"><h1>Filetype operations</h1></a><div class="top"><p class="src"><a id="v:getFileType" class="def">getFileType</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="HPath-IO.html#t:FileType" title="HPath.IO">FileType</a> <a href="src/HPath.IO.html#getFileType" class="link">Source</a> <a href="#v:getFileType" class="selflink">#</a></p><div class="doc"><p>Get the file type of the file located at the given path. Does
 not follow symbolic links.</p><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if the file does not exist</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:PermissionDenied" title="GHC.IO.Exception">PermissionDenied</a></code> if any part of the path is not accessible</li></ul></div></div><a href="#g:12" id="g:12"><h1>Others</h1></a><div class="top"><p class="src"><a id="v:canonicalizePath" class="def">canonicalizePath</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="HPath.html#t:Path" title="HPath">Path</a> <a href="HPath.html#t:Abs" title="HPath">Abs</a>) <a href="src/HPath.IO.html#canonicalizePath" class="link">Source</a> <a href="#v:canonicalizePath" class="selflink">#</a></p><div class="doc"><p>Applies <code>realpath</code> on the given path.</p><p>Throws:</p><ul><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if the file at the given path does not exist</li><li><code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/GHC-IO-Exception.html#v:NoSuchThing" title="GHC.IO.Exception">NoSuchThing</a></code> if the symlink is broken</li></ul></div></div><div class="top"><p class="src"><a id="v:toAbs" class="def">toAbs</a> :: <a href="HPath.html#t:Path" title="HPath">Path</a> b -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="HPath.html#t:Path" title="HPath">Path</a> <a href="HPath.html#t:Abs" title="HPath">Abs</a>) <a href="src/HPath.IO.html#toAbs" class="link">Source</a> <a href="#v:toAbs" class="selflink">#</a></p><div class="doc"><p>Converts any path to an absolute path.
 This is done in the following way:</p><ul><li>if the path is already an absolute one, just return it</li><li>if it's a relative path, prepend the current directory to it</li></ul></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>